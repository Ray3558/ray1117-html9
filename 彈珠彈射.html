<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MQTT 彈珠彈射遊戲 (三關卡版)</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; }
        .led-glow-on { box-shadow: 0 0 20px #ff4444, 0 0 40px #ff4444; animation: pulse-red 1.5s infinite; }
        .led-glow-off { box-shadow: 0 0 5px #666; }
        @keyframes pulse-red { 0%, 100% { box-shadow: 0 0 20px #ff4444, 0 0 40px #ff4444; } 50% { box-shadow: 0 0 30px #ff6666, 0 0 60px #ff6666; } }
        #gameCanvas { border: 3px solid #4f46e5; border-radius: 10px; background: linear-gradient(135deg, #1e1b4b 0%, #312e81 100%); }
        .connection-indicator { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        .connected { background-color: #10b981; box-shadow: 0 0 8px #10b981; animation: pulse-green 2s infinite; }
        .disconnected { background-color: #ef4444; }
        @keyframes pulse-green { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <div class="text-center mb-6">
            <h1 class="text-4xl font-bold text-white mb-2">MQTT 彈珠彈射遊戲</h1>
            <p class="text-gray-300">使用 MQTT 訊息控制球拍移動 (三關卡挑戰)</p>
        </div>

        <div class="flex flex-col lg:flex-row gap-6 max-w-6xl mx-auto">
            <div class="flex-1">
                <div class="bg-white bg-opacity-10 backdrop-blur-sm rounded-2xl p-6">
                    <div class="flex justify-around items-center mb-4">
                        <div class="text-white text-center"><span class="text-lg font-semibold">分數</span><br><span id="score" class="text-2xl font-bold text-yellow-400">0</span></div>
                        <div class="text-white text-center"><span class="text-lg font-semibold">時間</span><br><span id="timer" class="text-2xl font-bold text-cyan-400">0</span></div>
                        <div class="text-white text-center"><span class="text-lg font-semibold">評分</span><br><span id="rating" class="text-2xl font-bold text-green-400">-</span></div>
                        <div class="text-white text-center"><span class="text-lg font-semibold">生命</span><br><span id="lives" class="text-2xl font-bold text-red-400">3</span></div>
                    </div>
                    <canvas id="gameCanvas" width="600" height="400"></canvas>
                    <div class="mt-4 text-center">
                        <button id="startBtn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-6 rounded-lg transition-all duration-200 mr-4">開始遊戲</button>
                        <button id="resetBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg transition-all duration-200">重新開始</button>
                    </div>
                    <div class="mt-4 text-center text-gray-300 text-sm">MQTT控制: right=右移, left=左移 | 鍵盤控制: A=左, D=右</div>
                </div>
            </div>

            <div class="w-full lg:w-80">
                <div class="bg-black rounded-2xl p-6 mb-6">
                    <h3 class="text-white text-lg font-semibold mb-4 text-center">MQTT LED 狀態</h3>
                    <div class="text-center">
                        <div id="ledLight" class="w-20 h-20 mx-auto rounded-full bg-gray-600 led-glow-off transition-all duration-500 flex items-center justify-center mb-3">
                            <div id="ledCore" class="w-12 h-12 rounded-full bg-gray-700 transition-all duration-300"></div>
                        </div>
                        <div id="ledStatus" class="text-xl font-bold text-gray-400">IDLE</div>
                        <div class="text-sm text-gray-500 mt-1">當前指令狀態</div>
                    </div>
                </div>
                <div class="bg-white bg-opacity-10 backdrop-blur-sm rounded-2xl p-6 mb-6">
                    <h3 class="text-lg font-semibold text-white mb-4">MQTT 連線</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex items-center justify-between"><span class="text-gray-300">狀態:</span><div class="flex items-center"><div id="connectionIndicator" class="connection-indicator disconnected"></div><span id="connectionStatus" class="text-red-400 font-medium">未連線</span></div></div>
                        <div class="flex items-center justify-between"><span class="text-gray-300">伺服器:</span><span class="text-white font-mono text-xs">broker.MQTTGO.io:8084</span></div>
                        <div class="flex items-center justify-between"><span class="text-gray-300">節點:</span><span class="text-white font-mono text-xs break-all">RadioRingCon77/mpu6050/angleXYZ</span></div>
                        <div class="flex items-center justify-between"><span class="text-gray-300">最後指令:</span><span id="lastCommand" class="text-yellow-400 font-medium">-</span></div>
                    </div>
                </div>
                <div class="bg-white bg-opacity-10 backdrop-blur-sm rounded-2xl p-6">
                    <h3 class="text-lg font-semibold text-white mb-4">遊戲說明</h3>
                    <div class="text-gray-300 text-sm space-y-2">
                        <div>🎯 目標：完成三道關卡</div>
                        <div>🏆 過關目標：每關獲得 100 分</div>
                        <div>⏱️ 評分標準：時間越短，評分越高</div>
                        <div>❤️ 生命：球掉落會扣生命</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== Telegram Bot 設定 =====
        const TELEGRAM_BOT_TOKEN = '8285866980:AAG1yh-PA0U9DdQIhHonYtLQF48QZEzEqP4'; 
        const TELEGRAM_CHAT_ID = '-4926583753';

        // ===== 遊戲變數 =====
        let client = null;
        let isConnected = false;
        let ledState = false;
        let movementTimeout = null;
        const broker = 'ws://192.168.0.168:9001';
        const topic = 'RadioRingCon77/mpu6050/angleXYZ';
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let currentLevel = 1;
        let gameWon = false;
        const SCORE_PER_LEVEL = 100;

        let timerInterval = null;
        let levelStartTime = 0;
        
        // ===== DOM 元素 =====
        const timerElement = document.getElementById('timer');
        const ratingElement = document.getElementById('rating');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const ledLight = document.getElementById('ledLight');
        const ledCore = document.getElementById('ledCore');
        const ledStatus = document.getElementById('ledStatus');
        const connectionIndicator = document.getElementById('connectionIndicator');
        const connectionStatus = document.getElementById('connectionStatus');
        const lastCommand = document.getElementById('lastCommand');

        const ball = { x: canvas.width / 2, y: canvas.height - 50, dx: 3, dy: -3, radius: 8 };
        const initialPaddleWidth = canvas.width / 2;
        const paddle = { x: canvas.width / 2 - initialPaddleWidth / 2, y: canvas.height - 20, width: initialPaddleWidth, height: 15, speed: 15, moving: 0 };
        
        const bricks = [];
        const brickRows = 5, brickCols = 10, brickWidth = 55, brickHeight = 20, brickPadding = 3, brickOffsetTop = 50, brickOffsetLeft = 15;
        
        // ===== 核心功能函式 =====

        function calculateRating(t) {
            if (t >= 120) return 0; // 超過或等於120秒，評分為0
            const ratingScore = ((120 - t) / 90) * 100;
            // 使用 Math.round() 進行四捨五入取整數
            return Math.min(100, Math.round(ratingScore));
        }

        function sendTelegramMessage(message) {
            if (TELEGRAM_BOT_TOKEN === 'YOUR_TELEGRAM_BOT_TOKEN' || TELEGRAM_CHAT_ID === 'YOUR_TELEGRAM_CHAT_ID') {
                console.warn('Telegram Bot Token 或 Chat ID 未設定，無法發送訊息。請在程式碼中填寫。');
                return;
            }
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
            const params = { chat_id: TELEGRAM_CHAT_ID, text: message };
            fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(params) })
            .then(response => response.json())
            .then(data => console.log(data.ok ? 'Telegram 訊息發送成功' : 'Telegram 訊息發送失敗', data))
            .catch(error => console.error('發送 Telegram 訊息時發生網路錯誤:', error));
        }

        function initBricks() {
            bricks.length = 0;
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            for (let r = 0; r < brickRows; r++) {
                for (let c = 0; c < brickCols; c++) {
                    bricks.push({ x: c * (brickWidth + brickPadding) + brickOffsetLeft, y: r * (brickHeight + brickPadding) + brickOffsetTop, width: brickWidth, height: brickHeight, visible: true, color: colors[r], points: 10 });
                }
            }
        }

        function updateLEDStatus(state) {
             if (state === 'right') {
                ledState = true;
                ledLight.className = 'w-20 h-20 mx-auto rounded-full bg-red-500 led-glow-on transition-all duration-500 flex items-center justify-center';
                ledCore.className = 'w-12 h-12 rounded-full bg-red-300 transition-all duration-300';
                ledStatus.textContent = 'RIGHT';
                ledStatus.className = 'text-xl font-bold text-red-400';
            } else if (state === 'left') {
                ledState = false;
                ledLight.className = 'w-20 h-20 mx-auto rounded-full bg-blue-500 led-glow-on transition-all duration-500 flex items-center justify-center';
                ledCore.className = 'w-12 h-12 rounded-full bg-blue-300 transition-all duration-300';
                ledStatus.textContent = 'LEFT';
                ledStatus.className = 'text-xl font-bold text-blue-400';
            } else {
                ledState = false;
                ledLight.className = 'w-20 h-20 mx-auto rounded-full bg-gray-600 led-glow-off transition-all duration-500 flex items-center justify-center';
                ledCore.className = 'w-12 h-12 rounded-full bg-gray-700 transition-all duration-300';
                ledStatus.textContent = 'IDLE';
                ledStatus.className = 'text-xl font-bold text-gray-400';
            }
        }

        function updateConnectionStatus(connected) {
            isConnected = connected;
            connectionIndicator.className = connected ? 'connection-indicator connected' : 'connection-indicator disconnected';
            connectionStatus.textContent = connected ? '已連線' : '未連線';
            connectionStatus.className = connected ? 'text-green-400 font-medium' : 'text-red-400 font-medium';
        }

        function connectMQTT() {
            try {
                client = mqtt.connect(broker, { clientId: 'mqtt_game_' + Math.random().toString(16).substr(2, 8), clean: true, connectTimeout: 4000, reconnectPeriod: 1000 });
                client.on('connect', () => { updateConnectionStatus(true); client.subscribe(topic, (err) => { if (err) console.error('訂閱失敗:', err); }); });
                client.on('error', (error) => { console.error('連線錯誤:', error); updateConnectionStatus(false); });
                client.on('close', () => updateConnectionStatus(false));
                client.on('message', (receivedTopic, message) => {
                    const messageStr = message.toString().toLowerCase();
                    lastCommand.textContent = messageStr;
                    clearTimeout(movementTimeout);
                    if (messageStr === 'right') { updateLEDStatus('right'); paddle.moving = 1; } 
                    else if (messageStr === 'left') { updateLEDStatus('left'); paddle.moving = -1; }
                    movementTimeout = setTimeout(() => { paddle.moving = 0; updateLEDStatus('idle'); }, 100);
                });
            } catch (error) { console.error('MQTT 初始化失敗:', error); }
        }

        function drawBall() { ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fillStyle = '#ffffff'; ctx.fill(); ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 10; ctx.closePath(); ctx.shadowBlur = 0; }
        function drawPaddle() { ctx.fillStyle = ledState ? '#ff4444' : '#4ecdc4'; ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height); if (paddle.moving !== 0) { ctx.shadowColor = ledState ? '#ff4444' : '#4ecdc4'; ctx.shadowBlur = 15; ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height); ctx.shadowBlur = 0; } }
        function drawBricks() { bricks.forEach(brick => { if (brick.visible) { ctx.fillStyle = brick.color; ctx.fillRect(brick.x, brick.y, brick.width, brick.height); ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 1; ctx.strokeRect(brick.x, brick.y, brick.width, brick.height); } }); }

        function checkCollisions() {
            if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) ball.dx = -ball.dx;
            if (ball.y + ball.dy < ball.radius) ball.dy = -ball.dy;
            if (ball.y + ball.dy > paddle.y - ball.radius && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                let hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                ball.dx = hitPos * 5; ball.dy = -Math.abs(ball.dy);
            }
            for (let brick of bricks) {
                if (brick.visible && ball.x > brick.x && ball.x < brick.x + brick.width && ball.y > brick.y && ball.y < brick.y + brick.height) {
                    ball.dy = -ball.dy; brick.visible = false; score += brick.points; scoreElement.textContent = score;
                    if (!gameWon && score >= SCORE_PER_LEVEL) {
                        if (currentLevel < 3) levelUp(); else finalWin();
                        return;
                    }
                    break;
                }
            }
            if (ball.y + ball.dy > canvas.height) { lives--; livesElement.textContent = lives; if (lives <= 0) gameOver(); else resetBall(); }
        }

        function resetBall() { ball.x = canvas.width / 2; ball.y = canvas.height - 50; ball.dx = 3 * (Math.random() > 0.5 ? 1 : -1); ball.dy = -3; }
        
        function update() {
            if (paddle.moving === 1 && paddle.x < canvas.width - paddle.width) paddle.x += paddle.speed;
            else if (paddle.moving === -1 && paddle.x > 0) paddle.x -= paddle.speed;
            if (!gameRunning) return;
            ball.x += ball.dx; ball.y += ball.dy; checkCollisions();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBall(); drawPaddle(); drawBricks();
            if (!gameRunning) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff'; ctx.font = '24px "Noto Sans TC"'; ctx.textAlign = 'center';
                if (lives <= 0) { ctx.fillText('遊戲結束！', canvas.width / 2, canvas.height / 2 - 15); ctx.font = '18px "Noto Sans TC"'; ctx.fillText(`最終分數: ${score}`, canvas.width / 2, canvas.height / 2 + 20); } 
                else if (gameWon) { ctx.fillText('恭喜！已完成所有關卡！', canvas.width / 2, canvas.height / 2 - 15); ctx.font = '18px "Noto Sans TC"'; ctx.fillText(`最終分數: ${score}`, canvas.width / 2, canvas.height / 2 + 20); } 
                else if (startBtn.textContent === '繼續下一關') { ctx.fillText(`第 ${currentLevel - 1} 關完成！`, canvas.width / 2, canvas.height / 2 - 15); ctx.font = '18px "Noto Sans TC"'; ctx.fillText(`下一關目標: ${SCORE_PER_LEVEL} 分`, canvas.width / 2, canvas.height / 2 + 20); } 
                else { ctx.fillText('點擊「開始遊戲」按鈕', canvas.width / 2, canvas.height / 2); }
            }
        }

        function updateTimer() {
            const seconds = Math.floor((Date.now() - levelStartTime) / 1000);
            timerElement.textContent = seconds;
        }

        function startTimer() {
            clearInterval(timerInterval);
            levelStartTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

        function startGame() {
            if (!gameRunning && lives > 0) {
                gameRunning = true;
                ratingElement.textContent = '-';
                startTimer();
                startBtn.textContent = '遊戲進行中';
                startBtn.disabled = true;
            }
        }
        
        function continueGame() {
            gameRunning = true;
            initBricks();
            // ratingElement.textContent = '-'; // 讓上一關的評分繼續顯示
            startTimer();
            startBtn.textContent = '遊戲進行中';
            startBtn.disabled = true;
            startBtn.onclick = startGame;
        }

        function levelUp() {
            gameRunning = false;
            stopTimer();
            const timeTaken = Math.floor((Date.now() - levelStartTime) / 1000);
            const rating = calculateRating(timeTaken);
            ratingElement.textContent = rating;

            const now = new Date();
            const completionDate = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            const completionTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

            const message = `🎉 關卡 ${currentLevel} 完成！ 🎉\n\n遊戲名稱: MQTT 彈珠彈射遊戲\n本關分數: ${score}\n本關耗時: ${timeTaken} 秒\n過關評分: ${rating} 分\n過關日期: ${completionDate}\n過關時間: ${completionTime}\n\n準備進入下一關...`;
            sendTelegramMessage(message);

            score = 0; scoreElement.textContent = score;
            currentLevel++;
            resetBall();
            startBtn.textContent = '繼續下一關';
            startBtn.disabled = false;
            startBtn.onclick = continueGame;
        }
        
        function finalWin() {
            gameRunning = false;
            gameWon = true;
            stopTimer();
            const timeTaken = Math.floor((Date.now() - levelStartTime) / 1000);
            const rating = calculateRating(timeTaken);
            ratingElement.textContent = rating;

            const now = new Date();
            const completionDate = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            const completionTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

            const message = `🏆 恭喜！已完成所有關卡！ 🏆\n\n遊戲名稱: MQTT 彈珠彈射遊戲\n最終分數: ${score}\n最終關卡耗時: ${timeTaken} 秒\n過關評分: ${rating} 分\n過關日期: ${completionDate}\n過關時間: ${completionTime}`;
            sendTelegramMessage(message);

            startBtn.textContent = '再次挑戰';
            startBtn.disabled = false;
            startBtn.onclick = resetGame;
        }

        function resetGame() {
            gameRunning = false;
            stopTimer();
            timerElement.textContent = '0';
            ratingElement.textContent = '-';
            score = 0; lives = 3; currentLevel = 1; gameWon = false;
            paddle.width = initialPaddleWidth;
            scoreElement.textContent = score;
            livesElement.textContent = lives;
            startBtn.textContent = '開始遊戲';
            startBtn.disabled = false;
            startBtn.onclick = startGame;
            resetBall();
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.moving = 0;
            updateLEDStatus('idle');
            initBricks();
        }

        function gameOver() {
            gameRunning = false;
            stopTimer();
            
            const timeTaken = Math.floor((Date.now() - levelStartTime) / 1000);
            const now = new Date();
            const completionDate = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
            const completionTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

            const message = `☠️ 遊戲失敗！ ☠️\n\n遊戲名稱: MQTT 彈珠彈射遊戲\n最終分數: ${score}\n遊戲耗時: ${timeTaken} 秒\n失敗日期: ${completionDate}\n失敗時間: ${completionTime}`;
            sendTelegramMessage(message);

            startBtn.textContent = '重新開始';
            startBtn.disabled = false;
            startBtn.onclick = resetGame;
        }

        document.addEventListener('keydown', e => { if (e.key === 'a' || e.key === 'A') paddle.moving = -1; else if (e.key === 'd' || e.key === 'D') paddle.moving = 1; });
        document.addEventListener('keyup', e => { if ((e.key === 'a' || e.key === 'A') && paddle.moving === -1) paddle.moving = 0; else if ((e.key === 'd' || e.key === 'D') && paddle.moving === 1) paddle.moving = 0; });
        startBtn.addEventListener('click', startGame);
        resetBtn.addEventListener('click', resetGame);
        function initialize() { updateConnectionStatus(false); initBricks(); resetGame(); connectMQTT(); gameLoop(); }
        initialize();
    </script>
</body>
</html>

